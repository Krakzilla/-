<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content=height=device-height, initial-scale=1.0, initial-scale=1, maximum-scale=1/>
<style>
canvas {
  margin-top: 30px;
  border:1px solid #d3d3d3;
  background-color: #f6f9f1;
}
html {
overflow: hidden;
}
</style>
</head>
<body {margin: 0; height: 100%; overflow: hidden} onload="startGame()">
<p id="info">XwXwXwXwX</p>
<script>

var obstacleOne;
var myGamePiece;
var showStick;
var showMouse;
var gelaber;
var scale = (window.innerWidth / 320);
var paint = false;
var move = {x: 0, y: 0};
var beginning = {x: 0, y: 0};

function info(message){
  document.getElementById("info").innerHTML = message;
}
function startGame() {
  //let level = (1);
  myGamePiece = new component(30, 30, "red", 10, 120);
  myGameArea.start();
  obstacleOne = new ding(200, 200, "green", 100, 0, 1);
  gelaber = new nachricht("happy birtday yay");
//  levelOne();
}

/*function levelOne() {
  let nextEvent = (0)
  let bauplanListe = new Array(5, 400, 450)
    myGamePiece = new component(30, 30, "red", 10, 120);
    myGameArea.start();

  this.update = function(){
    //if (myGameArea.frameNo = bauplan[nextEvent])
info(bauplan[nextEvent]);
}}*/

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
      info(scale);
      document.body.style.height = (window.innerHeight + 50);
        this.canvas.width = (320*(window.innerWidth / 330));
        this.canvas.height = (480*(window.innerWidth / 330));
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.context.scale((window.innerWidth / 320), (window.innerWidth / 320));
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

}

function nachricht(inhalt) {

this.update = function(){
  ctx = myGameArea.context;
  ctx.font = ("lato");
  ctx.fillText(inhalt,100,100)
}
}


function ding(width, height, color, x, y, speed) {
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.speed = (speed);
    this.update = function(){
        this.y = this.y + this.speed;
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        if (this.y<(myGamePiece.y+25)){
         if (this.y+this.height>myGamePiece.y)
        {
          if (this.x<(myGamePiece.x+25)){
           if (this.x+this.width>myGamePiece.x)
          {
      //collision
              myGameArea.interval = clearInterval(myGameArea.interval);
          }
        }
        }
      }

    }
}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.update = function(){
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);

    this.input = function(x, y){
      this.x = this.x + x;
      this.y = this.y + y;
  if (this.x<0) {
    this.x = 0
  } else {
    if (this.x>280) {
      this.x = 280}
  }
  if (this.y<0) {
    this.y = 0
  } else {
    if (this.y>435) {
      this.y = 435}
  }

    }
    }}

function circle(r, color) {
  this.update = function(){
    ctx.globalAlpha = 0.5; // set global alpha
    ctx = myGameArea.context;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(beginning.x, beginning.y, r, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill()
    ctx.globalAlpha = 1;
   }
  }

window.addEventListener('load', () => {

    document.addEventListener('mousemove', getCoords);
    document.addEventListener('mousedown', startDrawing);
    document.addEventListener('mouseup', stopDrawing);

    document.addEventListener('touchmove', getCoords);
    document.addEventListener('touchstart', startDrawing);
    document.addEventListener('touchend', stopDrawing);
    document.addEventListener('touchcancel', stopDrawing);


});

function startDrawing() {
paint = true;
  var mouse_x = event.clientX || event.touches[0].clientX;
  var mouse_y = event.clientY || event.touches[0].clientY;
beginning.x = (mouse_x - myGameArea.canvas.offsetLeft)/scale;
beginning.y = (mouse_y - myGameArea.canvas.offsetTop)/scale;
    showStick = new circle (30, "rgb(204, 230, 255)");
    drawMouse = new mouse;
  }

function getCoords(event) {
move = { x: ((event.clientX || event.touches[0].clientX) - myGameArea.canvas.offsetLeft)/scale,
 y: ((event.clientY || event.touches[0].clientY) - myGameArea.canvas.offsetTop)/scale};
}

function mouse() {
  ctx.beginPath();
  ctx.arc(beginning.x, beginning.y, 4, 0, Math.PI * 2, true);
  ctx.closePath();
  move.x = beginning.x;
  move.y = beginning.y;
  this.update = function(event){
    let change = { x: (move.x-beginning.x)/7, y: (move.y-beginning.y)/7 };

/*if () {

} else {

}
*/
if (change.x > 8){
change.x = 8
move.x = 56+beginning.x
} else {
  if (change.x < -8){
  change.x = -8
  }
}
if (change.y > 8){
change.y = 8
move.y = 56+beginning.y
} else {
  if (change.y < -8){
  change.y = -8
  }
}

    myGamePiece.input(change.x, change.y);
      ctx = myGameArea.context;
      ctx.fillStyle = "rgb(0, 0, 0)";
      ctx.beginPath();
      ctx.arc(move.x, move.y, 4, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
      //info(move.x-beginning.x);
      }}

function stopDrawing(event) {
paint = false;
}


function updateGameArea() {
    myGameArea.clear();
    myGamePiece.update();
    myGameArea.frameNo += 1;
  if (myGameArea.frameNo === 480) {
    info(myGameArea.frameNo);
    obstacleOne = new ding(200, 200, "green", 100, -200, 1);
  }
  //  gelaber = new nachricht("na du hÃ¼bscher");
    obstacleOne.update();
    gelaber.update();
    if (paint) {
    showStick.update();
    drawMouse.update();
  }
}

</script>
</body>
</html>
